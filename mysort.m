function sortResult = mysort(data, thOpt, K)
    % Description: sort single channel for TDT Block data in .mat format
    % Input:
    %     data: TDT Block data, specified as a struct
    %     thOpt: "origin" or "reselect"(default)
    %             - "origin": use spikes of input data
    %             - "reselect": show at most 30 sec of wave for reselecting threshold for spikes extraction
    %     K: number of clusters. If not specified or left empty, an optimum K generated by KselectionMethod will be used
    % Output:
    %     sortResult: a struct array, each element of which is a result of one channel(electrode), containing fields:
    %                 - chanIdx: channel(electrode) number
    %                 - wave: spike waveforms of this channel(electrode), samples along row
    %                 - th: threshold for spike extraction (if thOpts is "reselect")
    %                 - spikeTimeAll: spike time of raw wave data (if used), noise included. (unit: sec)
    %                 - clusterIdx: cluster index of each spike waveform sample, with 0 as noise
    %                 - K: optimum K used in K-means
    %                 - KArray: possible K values
    %                 - SSEs: elbow method result
    %                 - gaps: gap statistic result
    %                 - pcaData: PCA result of spike waveforms
    %                 - clusterCenter: samples along row, in PCA space
    % Usage:
    %     sortResult = mysort(data); % reselect th and use an optimum K generated by gap_statistic
    %     sortResult = mysort(data, "origin"); % use spike waveforms of input data and an optimum K
    %     sortResult = mysort(data, "origin-reshape"); % use spikes of input data but reshape each spike waveform with user-specified wave length
    %     sortResult = mysort(data, "reselect", 3); % reselect th for spikes and specify K as 3
    %     spikes = sortResult.spikeTimeAll(sortResult.clusterIdx == 1); % spike times of cluster 1

    narginchk(1, 3);

    if nargin == 1
        thOpt = "reselect";
    elseif nargin == 3
        KmeansOpts.K = K;
    end

    addpath(genpath("Gap Statistic Algorithm\"));

    waves = data.streams.Wave.data;
    fs = data.streams.Wave.fs; % Hz

    %% Params Settings
    sortOpts.fs = fs;
    sortOpts.waveLength = 1.5e-3; % sec
    sortOpts.scaleFactor = 1e6;
    sortOpts.CVCRThreshold = 0.9;
    sortOpts.KselectionMethod = "gap";
    KmeansOpts.KArray = 1:10;
    KmeansOpts.maxIteration = 100;
    KmeansOpts.maxRepeat = 5;
    KmeansOpts.plotIterationNum = 0;
    sortOpts.KmeansOpts = KmeansOpts;

    %% Sort
    if strcmp(thOpt, "reselect")
        %% Reselect Th for Spike and Waveform Extraction
        t = 0:1 / fs:min([30, (length(waves) - 1) / fs]); % show at most 30 sec wave
        figure;
        plot(t, waves(1, 1:length(t)), 'b');
        xlabel('Time (sec)');
        ylabel('Voltage (V)');
        sortOpts.th = input('Input threshold for spike extraction (unit: V): ');
        
        channels = 1:size(waves, 1);
        sortResult = batchSorting(waves, channels, sortOpts);
    elseif strcmp(thOpt, "origin-reshape")
        %% Use Original Spikes for Waveform Extraction by user-specified wave length
        Waveforms = [];
        t = (0:length(waves) - 1) / fs;
        spikeTimeAll = data.snips.eNeu.ts; % sec
        disp('Waveforms extraction...');

        for sIndex = 1:length(spikeTimeAll)
            spikeTimeIndex = roundn(spikeTimeAll(sIndex) * fs, 0) - 1;

            if spikeTimeIndex - floor(sortOpts.waveLength / 2 * fs) > 0 && spikeTimeIndex + floor(sortOpts.waveLength / 2 * fs) <= length(t)
                Waveforms = [Waveforms; waves(spikeTimeIndex - floor(sortOpts.waveLength / 2 * fs) + 1:spikeTimeIndex + floor(sortOpts.waveLength / 2 * fs))];
            end

        end

        Waveforms = Waveforms * sortOpts.scaleFactor;
        disp('Waveforms extraction done.');
        channels = data.snips.eNeu.chan;
        sortResult = batchSorting([], channels, sortOpts, Waveforms);
        sortResult.spikeTimeAll = spikeTimeAll;
    elseif strcmp(thOpt, "origin")
        %% Use Original Spike Waveforms of data
        Waveforms = data.snips.eNeu.data * sortOpts.scaleFactor;
        channels = data.snips.eNeu.chan;
        sortResult = batchSorting([], channels, sortOpts, Waveforms);
        sortResult.spikeTimeAll = data.snips.eNeu.ts;
    else
        sortResult = [];
        warning('thOpt invalid!');
    end

    return;
end
