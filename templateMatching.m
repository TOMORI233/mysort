function sortResult = templateMatching(data, sortResult0)
    % Description: sort TDT data with template matching.
    %     Assume that data0 and data1 are different recorded protocol data from one cell or from one long-term recording data.
    %     Sort data0 with mysort to generate spike waveform templates and apply template matching to data1.
    %     The template matching algorithm is based on mean sqaure error (MSE).
    %     The basic principal is that the amplitude of spikes from the same cell follows a Gaussian normal distribution.
    %     Thus, MSEs between a template and waveforms also follow a Gaussian normal distribution.
    %     The confidence interval is [mean(MSE) - 3 * std(MSE), mean(MSE) + 3 * std(MSE)]
    % Input:
    %     data: TDT Block data, specified as a struct
    %           It should at least contain streams.Wave.data and streams.Wave.fs
    %     sortResult0: a struct of sorting result generated by mysort
    % Output:
    %     sortResult: sorting result of mysort. Refer to mysort.m for more information
    % Usage:
    %     sortResult0 = mysort(data0, [], "reselect", "preview");
    %     sortResult = templateMatching(data1, sortResult0);

    addpath(genpath(fileparts(mfilename('fullpath'))));
    wave = data.streams.Wave.data(1, :);

    %% Params Settings
    run(fullfile(fileparts(mfilename('fullpath')), 'config', 'defaultConfig.m'));
    sortOpts = getOrFull(sortResult0.sortOpts, defaultSortOpts);
    sortOpts.KmeansOpts = getOrFull(sortOpts.KmeansOpts, defaultSortOpts.KmeansOpts);
    
    if ~isfield(sortOpts, "fs") || isempty(sortOpts.fs)
        sortOpts.fs = data.streams.Wave.fs;
    end

    fs = sortOpts.fs;
    CVCRThreshold = sortOpts.CVCRThreshold;

    %% Generate Templates
    if ~isfield(sortResult0, "templates") || isempty(sortResult0.templates)
        templates = genTemplates(sortResult0);
    else
        templates = sortResult0.templates;
    end

    [tNum, tLen] = size(templates);
    th = sortResult0.th;
    sortResult.templates = templates;
    sortResult.K = sortResult0.K;
    sortResult.sortOpts = sortOpts;

    %% Spike Extraction
    disp('Extracting spikes...');
            
    try
        waveGPU = gpuArray(wave);
        [spikesGPU, spikeIndexAllGPU] = findpeaks(waveGPU, "MinPeakHeight", th, "MinPeakDistance", tLen / 2);
        [spikesAmp, spikeIndexAll] = gather(spikesGPU, spikeIndexAllGPU);
    catch
        warning("GPU device unavailable. Using CPU...");
        [spikesAmp, spikeIndexAll] = findpeaks(wave, "MinPeakHeight", th, "MinPeakDistance", tLen / 2);
    end

    if isempty(spikesAmp)
        error('No spikes detected in this channel');
    end

    %% Waveforms Extraction
    meanSpike = mean(spikesAmp);
    stdSpike = std(spikesAmp);

    % For this channel
    Waveforms = zeros(length(spikesAmp), tLen);
    spikeIndex = zeros(length(spikesAmp), 1);
    disp('Extracting Waveforms...');

    for sIndex = 1:length(spikesAmp)

        % Ignore the beginning and the end of the wave
        if spikeIndexAll(sIndex) - floor(tLen / 2) > 0 && spikeIndexAll(sIndex) + floor(tLen / 2) <= size(wave, 2)

            % Exclude possible artifacts
            if spikesAmp(sIndex) <= meanSpike + 3 * stdSpike
                Waveforms(sIndex, :) = wave(spikeIndexAll(sIndex) - floor(tLen / 2) + 1:spikeIndexAll(sIndex) + floor(tLen / 2));
                spikeIndex(sIndex) = spikeIndexAll(sIndex);
            end

        end

    end

    Waveforms(spikeIndex == 0, :) = [];
    spikeIndexAll(spikeIndex == 0) = [];

    sortResult.chanIdx = 1;
    sortResult.spikeTimeAll = (spikeIndexAll' - 1) / fs;
    sortResult.wave = Waveforms;

    % MATLAB - pca
    [~, SCORE, latent] = pca(Waveforms * 1e6);
    explained = latent / sum(latent);
    contrib = 0;

    for index = 1:size(explained, 1)
        contrib = contrib + explained(index);

        if contrib >= CVCRThreshold
            pcaData = SCORE(:, 1:index);
            break;
        end

    end

    sortResult.pcaData = pcaData;

    %% Template Matching
    disp('Template matching...');
    sortResult.clusterCenter = zeros(tNum, size(pcaData, 2));
    MSE = calMSE(Waveforms, templates);
    
    [MSE_min, sortResult.clusterIdx] = min(MSE, [], 2);
    sortResult.noiseClusterIdx = sortResult.clusterIdx;
    meanValue = mean(MSE, "all");
    stdValue = std(MSE, 0, "all");
    sortResult.clusterIdx(MSE_min < meanValue - stdValue * 3 | MSE_min > meanValue + stdValue * 3) = 0;
    sortResult.noiseClusterIdx(MSE_min >= meanValue - stdValue * 3 & MSE_min <= meanValue + stdValue * 3) = 0;

    for tIndex = 1:tNum
        sortResult.clusterCenter(tIndex, :) = mean(pcaData(sortResult.clusterIdx == tIndex, :));
    end

    disp('Matching Done.');
    return;
end